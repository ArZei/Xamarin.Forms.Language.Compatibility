using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.Build.Framework;
using Microsoft.Build.Utilities;
using ICSharpCode.NRefactory.CSharp;
using ICSharpCode.NRefactory.TypeSystem;
using ICSharpCode.NRefactory.TypeSystem.Implementation;

namespace Xamarin.Forms.Language.Compatibility
{
    public class CodeGenFixupTask : Task
    {

        [Required]
        public string[] References
        {
            get; set;
        }

        public string Source
        {
            get; set;
        }

        public string Language
        {
            get; set;
        }

        public string AssemblyName
        {
            get; set;
        }

        [Output]
        public string OutputFile
        {
            get; set;
        }

        public override bool Execute()
        {
            if (String.IsNullOrEmpty(Language) || Language.ToLower() == "csharp")
                return true;

            if (File.Exists(OutputFile))
            {
                GenerateFile(OutputFile);
            }

            return true;
        }

        // Parse the C# code generated by the XamGTask into an AST
        // Convert the AST into a CCU
        // Run the code dom provider for the specified language
        internal void GenerateFile(string outFile)
        {
            var provider = CodeDomProvider.CreateProvider(Language);
            
            var assemblyReferences = new List<IAssemblyReference>();
            foreach (var reference in References)
            {
                assemblyReferences.Add(new DefaultAssemblyReference(reference));
            }

            CodeCompileUnit ccu = null;
            using (StreamReader streamReader = File.OpenText(outFile))
            {
                var parser = new CSharpParser();
                var syntaxTree = parser.Parse(streamReader, Path.GetFileName(outFile) + ".tmp");
                if (syntaxTree.Errors.Count == 0)
                {
                    var convertVisitor = new ICSharpCode.NRefactory.CSharp.CodeDomConvertVisitor();

                    var file = syntaxTree.ToTypeSystem();
                    var project = new CSharpProjectContent().AddAssemblyReferences(assemblyReferences);
                    var compilation = project.CreateCompilation();

                    ccu = convertVisitor.Convert(compilation, syntaxTree, file);
                }
            }

            if (ccu != null)
            {
                // Translate LoadXaml into non-extension method
                FixupLoadFromXaml(ccu);

                using (StreamWriter streamWriter = File.CreateText(outFile))
                {
                    provider.GenerateCodeFromCompileUnit(ccu, streamWriter, new CodeGeneratorOptions());
                }
            }
        }

        // Search a simple CCU for the LoadFromXaml method and convert it into a static
        // method call instead of an extension method
        public void FixupLoadFromXaml(CodeCompileUnit ccu)
        {
            foreach (CodeNamespace ns in ccu.Namespaces)
            {
                foreach (CodeTypeDeclaration type in ns.Types)
                {
                    foreach (var method in type.Members.OfType<CodeMemberMethod>())
                    {
                        var members = method.Statements.OfType<CodeExpressionStatement>().ToList();
                        foreach (var member in members)
                        {
                            if (member.Expression is CodeMethodInvokeExpression)
                            {
                                var typedExpression = member.Expression as CodeMethodInvokeExpression;
                                if (typedExpression.Method.MethodName == "LoadFromXaml")
                                {
                                    // From:    this.LoadFromXaml(typeof(Page1))
                                    // To:      Extensions.LoadFromXaml(this, ^typeof(Page1))
                                    typedExpression.Method.TargetObject = new CodeTypeReferenceExpression("Extensions");
                                    typedExpression.Parameters.Insert(0, new CodeThisReferenceExpression());
                                    method.Statements[method.Statements.IndexOf(member)] = new CodeExpressionStatement(typedExpression);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
